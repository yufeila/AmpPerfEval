<!--
 * @Author: yyf 17786321727@163.com
 * @Date: 2025-07-07 17:16:51
 * @LastEditors: yyf 17786321727@163.com
 * @LastEditTime: 2025-07-07 21:37:49
 * @FilePath: /AmpPerfEval/问题记录.md
 * @Description: 这是默认设置,请设置`customMade`, 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
-->
# 问题记录

## 第一次软件调试

### 突破

1. 成功烧录,没有编译错误
2. 成功显示
3. 按键可以切换显示模式

### 问题

1. 频率测量和幅度测量
    1. 先不使用DDS模块产生信号输出，使用外部信号源给出了频率为1kHz，幅度为2V, 偏置为1V的信号，输入PA2, PA4, PA6, Basic Measurement 虽然确实在刷新，但是示数无变化。

2. 按键切换
    1. 复位后停留在Basic Measurement 界面，这是正确的，但是当按下key1 时，R_out只有在一瞬间有变化，之后又迅速变为 --- k, 而且在程序中我们好像忘记将Vout(RL)的值显示在屏幕上了，也就是说，显示R_out时，也要显示V_out(RL)

3. 扫频测量
    1. 前20个数据点的Progress更新较慢，后30个更新越来越快，这和我们频率选择有关吗？
    2. 当测量完成之后，按下key1, 频率扫描页面的一部分会覆盖基本测量显示的一部分。

4. dds模块：
    1. 查看了一下引脚设置，发现我好像把引脚设错了,Hal库中我是这样设置的
    PB4	n/a	Low	Output Push Pull	No pull-up and no pull-down	High	AD9851_RESET	true
    PB5	n/a	Low	Output Push Pull	No pull-up and no pull-down	High	AD9851_BIT_DATA	true
    PB6	n/a	Low	Output Push Pull	No pull-up and no pull-down	High	AD9851_W_CLK	true
    PB7	n/a	Low	Output Push Pull	No pull-up and no pull-down	High	AD9851_FQ_UP	true

### 修正

#### 1. 测量逻辑问题修正

**问题描述：**
- 按下key1切换到扫频模式时，`measure_r_out_flag`被清零
- 切换回基本测量模式后，R_out显示"--- kΩ"，无法显示之前的测量结果
- 测量触发标志与显示标志混用，导致状态混乱

**解决方案：**
1. **分离测量状态和显示状态**
   - 新增全局变量：`r_out_measured`（测量完成标志）和`r_out_value`（存储测量值）
   - `measure_r_out_flag`仅用于触发测量，测量完成后立即清零
   - `r_out_measured`用于控制显示状态，保持测量结果直到下次重置

2. **实现测量结果保存机制**
   ```c
   // Basic_Measurement函数中
   if(measure_r_out_flag) {
       // 测量过程...
       r_out_value = CalculateRout(&v_out, &v_open_drain_out);
       r_out_measured = 1;  // 标记已测量完成
       measure_r_out_flag = 0;  // 清除测量触发标志位
   }
   ```

3. **优化显示逻辑**
   ```c
   // Basic_Measurement_Page_Update函数中
   if(r_out_measured) {
       sprintf(dispBuff, "%.3f kΩ", r_out_value);
       LCD_ShowString(60, 190, 120, 12, 12, (uint8_t*)dispBuff);
   } else {
       LCD_ShowString(60, 190, 120, 12, 12, (uint8_t*)"--- kΩ");
   }
   ```

#### 2. 界面刷新问题修正

**问题描述：**
- 模式切换时没有正确清理上一个模式的显示内容
- 导致界面覆盖和显示错乱

**解决方案：**
1. **统一模式切换检测逻辑**
   - 移除混乱的`last_sweep_mode_state`变量
   - 统一使用标志位检测模式切换：
     - 基本测量模式：使用`basic_measurement_flag`
     - 扫频测量模式：使用`sweep_freq_response_flag`

2. **添加强制停止操作函数**
   ```c
   static void Force_Stop_All_Operations(void) {
       HAL_ADC_Stop_DMA(&hadc1);
       HAL_TIM_Base_Stop(&htim2);
       ADC_BufferReadyFlag = BUFFER_READY_FLAG_NONE;
       RELAY_OFF;
   }
   ```

3. **增强界面清理机制**
   - 模式切换时立即调用`Force_Stop_All_Operations()`
   - 完全清除屏幕：`LCD_Clear(WHITE)`
   - 添加50ms延时确保LCD清除完成
   - 重置相关状态和测量数据

4. **优化模式切换流程**
   ```c
   // 统一的模式切换检测模式
   if (mode_flag) {
       Force_Stop_All_Operations();  // 停止所有操作
       first_refresh = 1;           // 触发界面重新初始化
       mode_flag = 0;              // 清除标志位
       // 重置相关状态...
   }
   ```

#### 3. 代码结构优化

**新增函数：**
- `Reset_Rout_Measurement()`：重置输出阻抗测量状态
- `Force_Stop_All_Operations()`：强制停止所有运行中的操作

**移除冗余代码：**
- 删除`last_sweep_mode_state`变量及其相关逻辑
- 简化模式切换检测逻辑

#### 4. Vout(RL)显示问题

**当前状态：**
- 在`Basic_Measurement_Page_Update`函数中添加了Vout(RL)的显示占位符
- 当`r_out_measured=1`时显示"(measured)"，否则显示"--- V"

**待完善：**
- 需要在R_Out测量过程中保存实际的Vout(RL)值并显示

### 修改后的执行流程

```
用户按键 → 设置标志位 → 下次调用对应函数时检测到标志位 → 
强制停止操作 → 清除标志位 → 清除屏幕显示 → 触发界面重新初始化 → 
重置相关状态 → 正常运行
```

## 第二次软件调试

### 问题

1. 当程序进入状态2 current_system_state之后，就会莫名其妙的进入Error_Handler中断，并且lcd上没有进度显示。


2. 只有output signal DC的值在变化，Input signal和output signal 的Vs， f_s , V_out open 一直是0

3. Rout可以刷新，但是按键不灵敏，这个问题可以暂时先不修复

### 调试现象
1. 在current_system_state = =0x01时， PSC = 0, ARR = 0x833F, 感觉这好像不是我们最初的配置， ADC1的DR一直有数值
2. ADC_BufferReadyFlag确实时不时会被置为1

3. 一旦我按下key0,current_system_state = 0x02时，TIM2的时基单元配置就变为
PSC 0x05
ARR 0xDABF
之后就一直没变化了，此时如果我将运行的程序终止，程序会停在Error_Handler这里

### 调用栈分析结果

**错误发生路径：**
```
main() → Auto_Frequency_Response_Measurement() → Measure_Single_Point() → Process_ADC_Data_F32() → Error_Handler()
```

**关键参数：**
- frequency = 100 Hz （测量频率）
- fs = 250 Hz （采样频率）

**根本问题：采样频率过低**
- 采样频率250Hz对于100Hz信号严重不足
- 违反奈奎斯特定理（应≥200Hz，实际需要更高）
- 导致ADC+DMA+TIM配置异常

**紧急修复方案：**
1. 检查`Tim2_Config_AutoFs(100)`函数实现
2. 确保最小采样频率≥10kHz
3. 临时在扫频模式入口添加采样频率检查：
   ```c
   if(actual_fs < 1000.0f) {
       actual_fs = 10000.0f;  // 强制最小采样频率
   }
   ```

## 紧急修复状态更新 (2025-01-22)

### ? 当前修复状态：采样率下限保护已实施

#### ? 已完成的修复：
1. **采样率下限保护**（核心问题）
   - 在`tim.h`中新增两个安全采样率下限：
     - `SAMPLING_RATE_MIN = 10000U` (10kHz 最小下限)
     - `SAMPLING_RATE_SAFE_MIN = 20000U` (20kHz 推荐下限)
   
2. **Tim2_Config_AutoFs()函数修复**
   - 在步骤2中强制应用10kHz最小采样率约束
   - 在步骤5中添加最终安全检查，确保不低于20kHz推荐下限
   - 现在100Hz信号的采样率将被提升到至少20kHz，远高于奈奎斯特要求

3. **Tim2_Config_Channel_Fs()函数修复**
   - 同样添加采样率下限检查
   - 防止用户直接设置过低的采样率

#### ? 修复效果预期：
- **修复前**：100Hz信号 → 250Hz采样率（违反奈奎斯特定理）
- **修复后**：100Hz信号 → 20kHz采样率（满足2.5×f0=250Hz要求，且有充足裕量）

#### ? 建议测试步骤：
1. 编译并烧录修复后的代码
2. 在扫频测量中测试低频点（10Hz-200Hz）
3. 验证不再触发Error_Handler()
4. 检查采样率是否正确设置为≥20kHz

#### ? 深度防护修复（基于调用栈分析）

**调用栈分析确认：**
- 错误路径：`Measure_Single_Point()` → `Process_ADC_Data_F32()` → `Error_Handler()`
- 问题参数：frequency = 100Hz, fs = 250Hz
- 根本原因：采样率250Hz严重不足

**新增的三层保护机制：**

1. **第一层保护**：`Tim2_Config_AutoFs()` 函数内部
   - 强制采样率 ≥ 10kHz
   - 推荐采样率 ≥ 20kHz
   - 确保100Hz信号采样率提升到20kHz

2. **第二层保护**：`Start_ADC_DMA_TIM_System()` 函数
   - 双重检查返回的采样率
   - 如果仍然 < 10kHz，强制重新配置为20kHz

3. **第三层保护**：`Measure_Single_Point()` 函数
   - 在数据处理前最后一次检查采样率
   - 确保传递给 `Process_ADC_Data_F32()` 的采样率安全

**修复效果：**
- 原来：100Hz → 250Hz采样率 → Error_Handler()
- 现在：100Hz → 20kHz采样率 → 正常运行

**验证建议：**
重新编译烧录后，扫频测量应该不再在低频点触发Error_Handler。

#### ? 最小化修复方案（解决双重启动冲突）

**问题根本原因：**
- `Start_ADC_DMA_TIM_System()` 启动了 ADC+DMA+TIM
- `Process_ADC_Data_F32()` 又试图重新启动相同硬件
- 导致硬件状态冲突 → `Error_Handler()`

**最小化修复方案：**
只修改扫频测量的启动逻辑，将：
```c
// 原来：启动完整的ADC+DMA+TIM系统
float actual_fs = Start_ADC_DMA_TIM_System(input_freq);
```
改为：
```c
// 现在：只配置定时器，不启动硬件
float actual_fs = Tim2_Config_AutoFs(input_freq);
```

**修复效果：**
- 扫频测量中只配置定时器，不启动硬件
- `Process_ADC_Data_F32()` 负责启动和停止硬件
- 消除了双重启动冲突
- 保持了基本测量模式的正常工作

**测试验证：**
重新编译烧录后，扫频测量应该能正常进行，不再触发Error_Handler中断。

---

## AD9851引脚配置修复 (2025-01-22)

### ? 问题描述
AD9851模块的引脚配置与HAL库生成的引脚定义不匹配，需要将硬编码的GPIO引脚替换为宏定义以提高可移植性。

### ? 修复内容

#### 1. 引脚映射修正
**原始配置（错误）：**
```c
// GPIOB_PIN_6: AD9851_W_CLK_Pin (写时钟)  
// GPIOB_PIN_7: AD9851_FQ_UP_Pin (频率更新)
// GPIOB_PIN_8: AD9851_RESET_Pin (复位)     ?
// GPIOB_PIN_9: AD9851_BIT_DATA_Pin (数据位) ?
```

**修正后配置：**
```c
// GPIOB_PIN_4: AD9851_RESET_Pin (复位)     ?
// GPIOB_PIN_5: AD9851_BIT_DATA_Pin (数据位) ?  
// GPIOB_PIN_6: AD9851_W_CLK_Pin (写时钟)   ?
// GPIOB_PIN_7: AD9851_FQ_UP_Pin (频率更新) ?
```

#### 2. 头文件修改 (`bsp_ad9851.h`)
- 添加 `#include "main.h"` 包含HAL库引脚定义
- 使用可移植的宏定义替换硬编码引脚：
```c
#define AD9851_W_CLK_PIN     AD9851_W_CLK_Pin
#define AD9851_W_CLK_PORT    AD9851_W_CLK_GPIO_Port
#define AD9851_FQ_UP_PIN     AD9851_FQ_UP_Pin
#define AD9851_FQ_UP_PORT    AD9851_FQ_UP_GPIO_Port
#define AD9851_RESET_PIN     AD9851_RESET_Pin
#define AD9851_RESET_PORT    AD9851_RESET_GPIO_Port
#define AD9851_BIT_DATA_PIN  AD9851_BIT_DATA_Pin
#define AD9851_BIT_DATA_PORT AD9851_BIT_DATA_GPIO_Port
```

#### 3. 源文件修改 (`bsp_ad9851.c`)
**替换所有硬编码引脚引用：**
- `digitalH(GPIOB, GPIO_PIN_x)` → `digitalH(AD9851_xxx_PORT, AD9851_xxx_PIN)`
- `digitalL(GPIOB, GPIO_PIN_x)` → `digitalL(AD9851_xxx_PORT, AD9851_xxx_PIN)`
- `HAL_GPIO_WritePin(GPIOB, GPIO_PIN_x, ...)` → `HAL_GPIO_WritePin(AD9851_xxx_PORT, AD9851_xxx_PIN, ...)`

**修改的函数：**
- `ad9851_reset_serial()` - 串口模式复位
- `ad9851_wr_serial()` - 串口模式数据写入  
- `ad9851_reset_parallel()` - 并口模式复位
- `ad9851_wr_parallel()` - 并口模式数据写入
- `AD9851_Init()` - 初始化函数

### ? 修复效果
- **提高可移植性**：通过宏定义而非硬编码引脚，便于移植到不同硬件平台
- **匹配HAL配置**：与CubeMX生成的引脚定义完全一致
- **代码规范性**：遵循嵌入式开发最佳实践

### ? 验证方法
1. 编译项目确认无语法错误
2. 烧录到开发板测试DDS信号输出
3. 在扫频测量中验证频率设置功能

---

## 问题记录： ADC信号测量问题：

1. 我的Basic Measurement页面显示如下


?Input Signal
	?	Vin: 1V
	?	Vs: 0.000 V
	?	fs: 0.00 Hz
	?	Rin: 34028236692093848000（极大值，怀疑是浮点计算溢出或未初始化）

?

?Output Signal (AC)
	?	Vout (Open): 0.000 V
	?	Vout (RL): ― V
	?	fs: 0.00 Hz
	?	Rout: ― k（未检测出有效值）

?

?Output Signal (DC)
	?	Vout (DC): 0.866 V

其中，只有Vout (DC): 0.866 V的值在变化，其他Input Sige